import { createRequire } from 'module'

export const IATA_SOURCE_URL = 'https://datahub.io/core/airport-codes/r/airport-codes.csv'
export const UNLOCODE_FALLBACK_URL = 'https://raw.githubusercontent.com/datasets/un-locode/master/data/un-locode.csv'
export const NOMINATIM_BASE = 'https://nominatim.openstreetmap.org'

// Pre-bundled datasets (generated by scripts/generate-datasets.js)
// Use createRequire to load JSON in ESM without import assertions for broader compatibility
const require = createRequire(import.meta.url)
// eslint-disable-next-line @typescript-eslint/no-var-requires
const airportsData: any = require('./data/airports.min.json')
// eslint-disable-next-line @typescript-eslint/no-var-requires
const seaportsData: any = require('./data/seaports.min.json')

let cachedAirports: Airport[] | null = null
let cachedSeaports: Seaport[] | null = null

export interface Airport {
  iata_code: string
  name?: string
  municipality?: string
  iso_country?: string
  latitude?: number
  longitude?: number
}

export interface Seaport {
  locode: string
  name?: string
  country?: string // ISO alpha-2
  subdivision?: string
  function?: string
  latitude?: number
  longitude?: number
}

export interface PlaceCandidate {
  postalCode?: string
  countryCode?: string
  city?: string | null
  displayName?: string
  lat?: number
  lon?: number
}

export interface ResolveQuery {
  originText: string
  destinationText: string
  originCountryHint?: string
  destinationCountryHint?: string
  limit?: number
}

export interface ResolvedAir {
  originAirport: string
  destinationAirport: string
  originCandidates: PlaceCandidate[]
  destinationCandidates: PlaceCandidate[]
}

export interface ResolvedSea {
  originSeaport: string
  destinationSeaport: string
  originCandidates: PlaceCandidate[]
  destinationCandidates: PlaceCandidate[]
}

export interface ResolvedTruck {
  originPostalCode: string
  originCountry: string
  originCity?: string | null
  destinationPostalCode: string
  destinationCountry: string
  destinationCity?: string | null
  originCandidates: PlaceCandidate[]
  destinationCandidates: PlaceCandidate[]
}

export async function resolveAir(q: ResolveQuery): Promise<ResolvedAir> {
  const limit = clamp(Math.floor(q.limit ?? 5), 1, 10)
  if (!cachedAirports) cachedAirports = await loadAirports()

  const [orig, dest] = await Promise.all([
    nominatimSearch(q.originText, q.originCountryHint, limit),
    nominatimSearch(q.destinationText, q.destinationCountryHint, limit),
  ])

  const originAirport = pickBestAirport(orig, q.originCountryHint)
  const destinationAirport = pickBestAirport(dest, q.destinationCountryHint)

  if (!originAirport || !destinationAirport) {
    throw new Error('Could not resolve suitable airports for origin/destination')
  }

  return {
    originAirport,
    destinationAirport,
    originCandidates: orig,
    destinationCandidates: dest,
  }
}

export async function resolveSea(q: ResolveQuery): Promise<ResolvedSea> {
  const limit = clamp(Math.floor(q.limit ?? 5), 1, 10)
  if (!cachedSeaports) cachedSeaports = await loadSeaports()

  const [orig, dest] = await Promise.all([
    nominatimSearch(q.originText, q.originCountryHint, limit),
    nominatimSearch(q.destinationText, q.destinationCountryHint, limit),
  ])

  const originSeaport = pickBestSeaport(orig, q.originCountryHint)
  const destinationSeaport = pickBestSeaport(dest, q.destinationCountryHint)

  if (!originSeaport || !destinationSeaport) {
    throw new Error('Could not resolve suitable seaports for origin/destination')
  }

  return {
    originSeaport,
    destinationSeaport,
    originCandidates: orig,
    destinationCandidates: dest,
  }
}

export async function resolveTruck(q: ResolveQuery): Promise<ResolvedTruck> {
  const limit = clamp(Math.floor(q.limit ?? 5), 1, 10)
  const [origRaw, destRaw] = await Promise.all([
    nominatimSearch(q.originText, q.originCountryHint, limit),
    nominatimSearch(q.destinationText, q.destinationCountryHint, limit),
  ])
  // Enrich candidates with reverse geocoding to ensure postal codes when inputs are broad (e.g., states)
  const [orig, dest] = await Promise.all([
    enrichCandidatesWithReverse(origRaw, limit),
    enrichCandidatesWithReverse(destRaw, limit),
  ])

  const o = pickBestPostalCandidate(orig)
  const d = pickBestPostalCandidate(dest)

  if (!o?.postalCode || !o?.countryCode || !d?.postalCode || !d?.countryCode) {
    throw new Error('Could not resolve postal codes/countries for ground transport')
  }

  return {
    originPostalCode: o.postalCode,
    originCountry: o.countryCode,
    originCity: o.city,
    destinationPostalCode: d.postalCode,
    destinationCountry: d.countryCode,
    destinationCity: d.city,
    originCandidates: orig,
    destinationCandidates: dest,
  }
}

// Internal helpers
export async function nominatimSearch(query: string, countryCode?: string, limit: number = 5): Promise<PlaceCandidate[]> {
  const params = new URLSearchParams({
    q: query,
    format: 'json',
    addressdetails: '1',
    limit: String(Math.min(limit, 10)),
    extratags: '1',
  })
  if (countryCode) params.set('countrycodes', countryCode.toLowerCase())

  const url = `${NOMINATIM_BASE}/search?${params.toString()}`
  const resp = await fetch(url, {
    headers: {
      'User-Agent': 'CarbonCare-Resolver/1.0 (contact@example.com)',
    },
  })
  if (!resp.ok) return []
  const data = (await resp.json()) as any[]

  const out: PlaceCandidate[] = []
  for (const item of data) {
    const address = item?.address || {}
    const postal = address.postcode as string | undefined
    const cc = (address.country_code as string | undefined)?.toUpperCase()
    const city = (address.city || address.town || address.village || null) as string | null
    out.push({
      postalCode: postal,
      countryCode: cc,
      city,
      displayName: item?.display_name,
      lat: numberOrUndefined(item?.lat),
      lon: numberOrUndefined(item?.lon),
    })
  }
  // Deduplicate by postal+country
  const seen = new Set<string>()
  return out.filter(c => {
    const key = `${c.postalCode || ''}|${c.countryCode || ''}`
    if (seen.has(key)) return false
    seen.add(key)
    return true
  })
}

// For broad areas without postal codes, reverse geocode the centroid to obtain a concrete postal/city
export async function nominatimReverse(lat: number, lon: number, zoom: number = 18): Promise<PlaceCandidate | null> {
  const params = new URLSearchParams({
    lat: String(lat),
    lon: String(lon),
    format: 'json',
    addressdetails: '1',
    extratags: '1',
    zoom: String(zoom),
  })
  const url = `${NOMINATIM_BASE}/reverse?${params.toString()}`
  const resp = await fetch(url, {
    headers: {
      'User-Agent': 'CarbonCare-Resolver/1.0 (contact@example.com)',
    },
  })
  if (!resp.ok) return null
  const data = await resp.json()
  const address = data?.address || {}
  const postal = address.postcode as string | undefined
  const cc = (address.country_code as string | undefined)?.toUpperCase()
  const city = (address.city || address.town || address.village || null) as string | null
  const displayName = data?.display_name as string | undefined
  return {
    postalCode: postal,
    countryCode: cc,
    city,
    displayName,
    lat: typeof data?.lat !== 'undefined' ? Number(data.lat) : lat,
    lon: typeof data?.lon !== 'undefined' ? Number(data.lon) : lon,
  }
}

async function reverseWithPostalFallback(lat: number, lon: number): Promise<PlaceCandidate | null> {
  const zoomLevels = [18, 16, 14, 12]
  for (const z of zoomLevels) {
    const cand = await nominatimReverse(lat, lon, z)
    if (cand?.postalCode && cand.countryCode) return cand
  }
  return await nominatimReverse(lat, lon, 16)
}

async function enrichCandidatesWithReverse(cands: PlaceCandidate[], max: number): Promise<PlaceCandidate[]> {
  const top = cands.slice(0, Math.max(1, Math.min(5, max)))
  const enriched = await Promise.all(
    top.map(async (c) => {
      if ((c.postalCode && c.countryCode) || !c.lat || !c.lon) return c
      const rev = await reverseWithPostalFallback(c.lat, c.lon)
      if (!rev) return c
      return {
        postalCode: c.postalCode || rev.postalCode,
        countryCode: c.countryCode || rev.countryCode,
        city: c.city || rev.city,
        displayName: c.displayName || rev.displayName,
        lat: c.lat ?? rev.lat,
        lon: c.lon ?? rev.lon,
      }
    })
  )
  // Preserve original order; append remaining tail
  return enriched.concat(cands.slice(enriched.length))
}

function pickBestPostalCandidate(cands: PlaceCandidate[]): PlaceCandidate | undefined {
  const withPostal = cands.filter(c => c.postalCode && c.countryCode)
  if (withPostal.length) return withPostal[0]
  // As a last resort, return the top candidate even without postal; caller will re-validate
  return cands[0]
}

async function loadAirports(): Promise<Airport[]> {
  // Use pre-bundled JSON only; no CSV fallback
  const pre = airportsData as Airport[] | undefined
  if (pre && Array.isArray(pre) && pre.length) return pre
  throw new Error('Airports dataset not found. Ensure lib/data/airports.min.json is present or run dataset generation.')
}

async function loadSeaports(): Promise<Seaport[]> {
  // Use pre-bundled JSON only; no CSV fallback
  const pre = seaportsData as Seaport[] | undefined
  if (pre && Array.isArray(pre) && pre.length) return pre
  throw new Error('Seaports dataset not found. Ensure lib/data/seaports.min.json is present or run dataset generation.')
}

function pickBestAirport(cands: PlaceCandidate[], countryHint?: string): string | undefined {
  if (!cachedAirports) return undefined
  const anchor = cands[0]
  const country = countryHint?.toUpperCase() || anchor?.countryCode
  const scored = cachedAirports
    .filter(a => a.iata_code && a.iata_code.length === 3)
    .map(a => {
      const nameText = `${a.name || ''} ${a.municipality || ''}`.trim()
      const matchScore = tokenScore(tokenize(anchor?.displayName || ''), nameText)
      const countryScore = a.iso_country && country && a.iso_country.toUpperCase() === country ? 1 : 0
      const distance = anchor?.lat && anchor?.lon && a.latitude && a.longitude ? haversineKm(anchor.lat!, anchor.lon!, a.latitude, a.longitude) : undefined
      const proximityScore = distance !== undefined ? scoreDistance(distance) : 0
      const total = matchScore * 0.6 + countryScore * 0.25 + proximityScore * 0.15
      return { a, total }
    })
    .sort((x, y) => y.total - x.total)

  if (scored.length && scored[0].total > 0) return scored[0].a.iata_code

  // Fallback: choose nearest airport within country (if we have an anchor with coordinates)
  if (anchor?.lat && anchor?.lon) {
    const pool = cachedAirports.filter(a => a.iata_code && a.latitude && a.longitude)
      .filter(a => (country ? a.iso_country?.toUpperCase() === country : true))
    const nearest = pool
      .map(a => ({ a, d: haversineKm(anchor.lat!, anchor.lon!, a.latitude!, a.longitude!) }))
      .sort((x, y) => x.d - y.d)[0]
    if (nearest) return nearest.a.iata_code
  }

  // Last resort: any airport matching country, else first available
  const byCountry = cachedAirports.find(a => a.iso_country && country && a.iso_country.toUpperCase() === country && a.iata_code)
  return byCountry?.iata_code || cachedAirports.find(a => a.iata_code)?.iata_code
}

function pickBestSeaport(cands: PlaceCandidate[], countryHint?: string): string | undefined {
  if (!cachedSeaports) return undefined
  const anchor = cands[0]
  const country = countryHint?.toUpperCase() || anchor?.countryCode
  const scored = cachedSeaports
    .filter(p => p.locode && p.name)
    .map(p => {
      const matchScore = tokenScore(tokenize(anchor?.displayName || ''), p.name || '')
      const countryScore = p.country && country && p.country.toUpperCase() === country ? 1 : 0
      const distance = anchor?.lat && anchor?.lon && p.latitude && p.longitude ? haversineKm(anchor.lat!, anchor.lon!, p.latitude, p.longitude) : undefined
      const proximityScore = distance !== undefined ? scoreDistance(distance) : 0
      const total = matchScore * 0.6 + countryScore * 0.25 + proximityScore * 0.15
      return { p, total }
    })
    .sort((x, y) => y.total - x.total)

  if (scored.length && scored[0].total > 0) return scored[0].p.locode

  // Fallback: nearest seaport within country
  if (anchor?.lat && anchor?.lon) {
    const pool = cachedSeaports.filter(p => p.locode && p.latitude && p.longitude)
      .filter(p => (country ? p.country?.toUpperCase() === country : true))
    const nearest = pool
      .map(p => ({ p, d: haversineKm(anchor.lat!, anchor.lon!, p.latitude!, p.longitude!) }))
      .sort((x, y) => x.d - y.d)[0]
    if (nearest) return nearest.p.locode
  }

  // Last resort: any seaport in country, else first available
  const byCountry = cachedSeaports.find(p => p.country && country && p.country.toUpperCase() === country && p.locode)
  return byCountry?.locode || cachedSeaports.find(p => p.locode)?.locode
}

// Generic utilities
function tokenize(text: string): string[] {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, ' ')
    .split(/\s+/)
    .filter(Boolean)
}

function tokenScore(tokens: string[], hay: string): number {
  if (!hay) return 0
  const lower = hay.toLowerCase()
  let hits = 0
  for (const t of tokens) if (t.length > 1 && lower.includes(t)) hits += 1
  return tokens.length ? hits / tokens.length : 0
}

function scoreDistance(km: number): number {
  if (km <= 0) return 1
  return Math.max(0, 1 - Math.log10(1 + km) / Math.log10(1000))
}

function haversineKm(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371
  const dLat = toRad(lat2 - lat1)
  const dLon = toRad(lon2 - lon1)
  const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
  return R * c
}

function toRad(d: number): number { return (d * Math.PI) / 180 }
function clamp(n: number, min: number, max: number): number { return Math.min(max, Math.max(min, n)) }
function numberOrUndefined(v: any): number | undefined { const n = Number(v); return Number.isFinite(n) ? n : undefined }
function parseCoord(coord: any): { lat: number; lon: number } | undefined {
  if (!coord) return undefined
  const s = String(coord)
  if (s.includes(',')) {
    const parts = s.split(',').map((p: string) => Number(p.trim()))
    if (parts.length >= 2 && parts.every(Number.isFinite)) {
      return { lat: parts[1], lon: parts[0] }
    }
  }
  return undefined
}
function parseUNLocodeCoords(_s: any): { lat: number; lon: number } | undefined {
  const s = _s ? String(_s).replace(/\s+/g, '') : ''
  const m = s.match(/^(\d{2})(\d{2})([NS])(\d{3})(\d{2})([EW])$/)
  if (!m) return undefined
  const latDeg = Number(m[1])
  const latMin = Number(m[2])
  const latHem = m[3]
  const lonDeg = Number(m[4])
  const lonMin = Number(m[5])
  const lonHem = m[6]
  let lat = latDeg + latMin / 60
  let lon = lonDeg + lonMin / 60
  if (latHem === 'S') lat = -lat
  if (lonHem === 'W') lon = -lon
  return { lat, lon }
}